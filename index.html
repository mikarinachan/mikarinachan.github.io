<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>受験数学難問発掘会</title>
  <link rel="stylesheet" href="style.css" />

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']]
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea']
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      background: #f6f6f6;
      color: #111;
    }
    header {
      background: #222;
      color: #fff;
      padding: 1.2rem 1rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: .02em;
    }
    header p {
      margin: .25rem 0 0;
      opacity: .85;
      font-size: .95rem;
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 1.2rem 1rem 3rem;
    }
    .post {
      background: #fff;
      border-radius: 14px;
      padding: 1.25rem 1.25rem 1rem;
      margin: 0 0 1rem;
      box-shadow: 0 1px 10px rgba(0,0,0,.06);
    }
    .meta {
      color: #666;
      font-size: 0.92rem;
      margin-bottom: 0.75rem;
    }
    .content .tex {
      white-space: pre-wrap;
      font-size: 1.03rem;
      line-height: 1.75;
      background: #fafafa;
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid #eee;
      overflow-wrap: anywhere;
    }
    .explain {
      margin-top: .8rem;
      padding: .75rem .9rem;
      border-left: 4px solid #ddd;
      background: #fcfcfc;
      border-radius: 10px;
    }
    .answer {
      margin-top: .7rem;
    }
    .answer a {
      color: #0b57d0;
      text-decoration: none;
    }
    .answer a:hover { text-decoration: underline; }

    .avg { margin-top: .9rem; color:#333; }
    .rating { margin-top: .6rem; display:flex; gap:.35rem; flex-wrap:wrap; }
    .rating button {
      border: 1px solid #bbb;
      background: #f4f4f4;
      border-radius: 8px;
      padding: .45rem .65rem;
      cursor: pointer;
      min-width: 2.4rem;
    }
    .rating button:hover { background: #eee; }
    .rating button:disabled { opacity: .55; cursor: not-allowed; }
    .rating button.selected { border-color: #111; background: #e7e7e7; }

    .system-note {
      padding: .8rem 1rem;
      border-radius: 12px;
      background: #fff3cd;
      border: 1px solid #ffe69c;
      color: #664d03;
      margin: 0 0 1rem;
    }
    .muted { color: #777; font-size: .95rem; }

    .qnum {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 2.2em;
  height: 2.2em;
  border: 2px solid #222;
  border-radius: 6px;
  font-weight: 700;
  background: #fff;
  margin-bottom: 0.6em;
}

    

  </style>
</head>

<body>
<header>
  <h1>受験数学難問発掘会</h1>
  <p>サイト作成: みかりな</p>
</header>

<main id="timeline"></main>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getFirestore, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  /* ---------- Firebase ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyCfyTtuLXAmibDu2ebKSTUI-_ZKFrv8Syo",
    authDomain: "math-memo-870c0.firebaseapp.com",
    projectId: "math-memo-870c0",
    storageBucket: "math-memo-870c0.firebasestorage.app",
    messagingSenderId: "396039327636",
    appId: "1:396039327636:web:028aa61574d06623240981"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  /* ---------- DOM ---------- */
  const timeline = document.getElementById("timeline");
  let sortMode = "year"; // ★追加：並び替えモード（年度順/難易度順）

  // --- 検索UI ---
// --- 検索UI ---
const toolbar = document.createElement("div");
toolbar.style.display = "flex";
toolbar.style.gap = "0.6rem";
toolbar.style.alignItems = "center";
toolbar.style.margin = "0 0 1rem";

const searchInput = document.createElement("input");
searchInput.type = "search";
searchInput.placeholder = "検索（例: 2025 / 6 / 複素数 / Re / 4a+1 など）";
searchInput.style.flex = "1";
searchInput.style.padding = "0.7rem 0.9rem";
searchInput.style.borderRadius = "10px";
searchInput.style.border = "1px solid #ddd";
searchInput.style.fontSize = "1rem";
searchInput.autocomplete = "off";

const clearBtn = document.createElement("button");
clearBtn.textContent = "クリア";
clearBtn.style.padding = "0.7rem 0.9rem";
clearBtn.style.borderRadius = "10px";
clearBtn.style.border = "1px solid #ddd";
clearBtn.style.background = "#fff";
clearBtn.style.cursor = "pointer";

clearBtn.onclick = () => {
  searchInput.value = "";
  searchInput.dispatchEvent(new Event("input"));
};

// ★並び替えボタン（定義は1回だけ）
const sortToggle = document.createElement("button");
sortToggle.textContent = "並び順：年度順";
sortToggle.style.padding = "0.7rem 0.9rem";
sortToggle.style.borderRadius = "10px";
sortToggle.style.border = "1px solid #ddd";
sortToggle.style.background = "#fff";
sortToggle.style.cursor = "pointer";

toolbar.appendChild(searchInput);
toolbar.appendChild(clearBtn);
toolbar.appendChild(sortToggle);
timeline.before(toolbar);




  function showNote(html) {
    const div = document.createElement("div");
    div.className = "system-note";
    div.innerHTML = html;
    timeline.prepend(div);
  }

  /* ---------- util: encoding付き fetch ---------- */
  async function fetchTextWithEncoding(url, encoding = "utf-8") {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${url}`);
  const buf = await res.arrayBuffer();

  try {
    return new TextDecoder(encoding).decode(buf);
  } catch (e) {
    console.warn(`TextDecoder(${encoding}) 失敗 → utf-8で再試行`, e);
    return new TextDecoder("utf-8").decode(buf);
  }
}


  /* ---------- util: LaTeX → 表示用に正規化（MathJax非対応を剥がす） ---------- */
  function normalizeLatexForMathJax(tex) {
    return tex
      // document前後を削除
      .replace(/^[\s\S]*?\\begin\{document\}/, "")
      .replace(/\\end\{document\}[\s\S]*$/, "")

      // よくある前置き命令を削除（MathJaxは組版しない）
      .replace(/\\documentclass(\[[^\]]*\])?\{[^}]*\}/g, "")
      .replace(/\\usepackage(\[[^\]]*\])?\{[^}]*\}/g, "")
      .replace(/\\pagestyle\{[^}]+\}/g, "")
      .replace(/\\setlength\{[^}]+\}\{[^}]+\}/g, "")

      // 文字サイズ命令を削除（{\huge 6} → 6）
      .replace(/\\(?:tiny|scriptsize|footnotesize|small|normalsize|large|Large|LARGE|huge|Huge)\b/g, "")

      // 文章レイアウト環境は剥がす（中身だけ表示）
      .replace(/\\begin\{(?:flushleft|center|flushright)\}/g, "")
      .replace(/\\end\{(?:flushleft|center|flushright)\}/g, "")
      .replace(/\\begin\{(?:description|itemize|enumerate)\}/g, "")
      .replace(/\\end\{(?:description|itemize|enumerate)\}/g, "")
      // {4} みたいな行頭の番号をバッジ用HTMLに変換
      .replace(/^\s*\{(\d+)\}\s*$/m, '<span class="qnum">$1</span>')


      // item を見やすく
      // \item[(1)] → （1）
      .replace(/\\item\s*\[\((\d+)\)\]\s*/g, "\n（$1）")
      // \item[foo] → foo：
      .replace(/\\item\s*\[([^\]]+)\]\s*/g, "\n$1：")
      // \item → ・
      .replace(/\\item\b\s*/g, "\n・")

      // ありがちな整形
      .replace(/\u3000+/g, " ")        // 全角スペース多重を1個に
      .replace(/\r\n/g, "\n")          // 改行統一
      .replace(/\n{3,}/g, "\n\n")      // 空行詰め
      .trim();
  }

  /* ---------- posts 自動生成（GitHub API） ---------- */
  async function loadPostIndex() {
  const r = await fetch("posts_index.json", { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status}: posts_index.json`);
  const posts = await r.json();

  const cleaned = posts
    .filter(p => p && p.id && p.tex)
    .map(p => ({
  id: String(p.id),
  tex: String(p.tex),
  date: String(p.date ?? ""),
  no: Number(p.no ?? 0),
  source: String(p.source ?? "入試問題"),
  encoding: String(p.encoding ?? "utf-8"),
  explain: String(p.explain ?? ""),   // ★追加
  answer: String(p.answer ?? ""),     // ★追加
  body: ""
}));


  cleaned.sort((a, b) => (b.date.localeCompare(a.date) || a.no - b.no));
  return cleaned;
}



  /* ---------- ratings（落ちても表示継続） ---------- */
  async function loadRatings() {
    let ratingMap = {};
    try {
      const snap = await getDocs(collection(db, "ratings"));
      snap.forEach(doc => {
        const { postId, score } = doc.data() || {};
        if (!postId || typeof score !== "number") return;
        (ratingMap[postId] ??= []).push(score);
      });
    } catch (e) {
      console.warn("ratings 読み取り失敗（権限など）:", e);
      ratingMap = {};
      showNote("⚠️ 難易度データ（Firestore）が読み取れませんでした。表示は続行します。<div class='muted'>Console に詳細があります。</div>");
    }
    return ratingMap;
  }

  /* ---------- tex 本文読み込み ---------- */
  async function loadBodies(posts) {
    for (const p of posts) {
      try {
        const raw = await fetchTextWithEncoding(p.tex, p.encoding || "utf-8");
        p.body = normalizeLatexForMathJax(raw);
      } catch (e) {
        console.error(e);
        p.body = `（tex 読み込み失敗: ${p.tex}）`;
      }
    }
    return posts;
  }

  /* ---------- 描画 ---------- */
  function buildCard(p, alreadyRated) {
    const div = document.createElement("div");
    div.className = "post";

    div.innerHTML = `
      <div class="meta">${p.date}｜${p.source}</div>

      <div class="content">
        <div class="tex"></div>
      </div>

      ${p.explain ? `<div class="explain">解説：${p.explain}</div>` : ""}

      ${p.answer ? `
        <div class="answer">
          <a href="${p.answer}" target="_blank" rel="noopener">▶ 模範解答を見る</a>
        </div>` : ""}

      <div class="avg" data-avg>
        平均難易度：<b>${p.count ? p.avg.toFixed(2) : "未評価"}</b>
        ${p.count ? `（${p.count}人）` : ""}
      </div>

      <div class="rating">
        ${[1,2,3,4,5,6,7,8,9,10].map(n =>
          `<button data-score="${n}" ${alreadyRated ? "disabled" : ""}>${n}</button>`
        ).join("")}
      </div>
    `;
    return div;
  }

  async function main() {
    let posts = [];
    try {
      posts = await loadPostIndex();
    } catch (e) {
      console.error(e);
      showNote(`❌ posts/ の一覧取得に失敗しました。<div class="muted">${String(e.message || e)}</div>`);
      return;
    }

    if (posts.length === 0) {
      showNote("⚠️ posts/ に対象ファイルが見つかりません。<div class='muted'>ファイル名は <b>2025_6.tex</b> のように <b>YYYY_N.tex</b> 形式にしてください。</div>");
      return;
    }

    // ratings
    const ratingMap = await loadRatings();

    // tex本文
    // 表示時に初めて読み込む（キャッシュあり）



    // enriched
    const enriched = posts.map(p => {
      const scores = ratingMap[p.id] ?? [];
      const avg = scores.length ? (scores.reduce((a,b)=>a+b,0) / scores.length) : 0;
      return { ...p, avg, count: scores.length };
});

// ★ここに追加


function sortPosts(list) {
  const arr = list.slice();

  if (sortMode === "difficulty") {
    arr.sort((a, b) => b.avg - a.avg);
  } else {
    // 年度降順 → 問題番号昇順
    arr.sort((a, b) => {
      const d = b.date.localeCompare(a.date);

      if (d !== 0) return d;
      return a.no - b.no;
    });
  }

  return arr;
}


    // 表示順：いまは「年度降順→番号昇順」。難易度順にしたければ下の行を有効化
    // enriched.sort((a,b) => b.avg - a.avg);
// --- 無限スクロール設定 ---
const PAGE_SIZE = 5;
let currentList = enriched.slice();   // 表示対象（検索で変わる）
let rendered = 0;         // 何件描画したか
let isLoading = false;   // ★追加：二重描画防止
let observer = null;

const sentinel = document.createElement("div");
sentinel.style.height = "1px";

// 1件カードを描画する関数（既存 buildCard を使う）
async function renderOne(p) {
  const ratedKey = `rated_${p.id}`;
  const alreadyRated = localStorage.getItem(ratedKey);

  const card = buildCard(p, alreadyRated);
  const texEl = card.querySelector(".tex");

  // ★ qnum をHTMLで出したい場合は innerHTML / それ以外は textContent
  // いま「□4」化をするなら innerHTML にしてください
  if (!p.body) {
  const raw = await fetchTextWithEncoding(p.tex, p.encoding || "utf-8");
  p.body = normalizeLatexForMathJax(raw);
}
texEl.innerHTML = p.body;


  const avgDiv = card.querySelector("[data-avg]");

  card.querySelectorAll("button").forEach(btn => {
    btn.onclick = async () => {
      if (localStorage.getItem(ratedKey)) return;

      const score = Number(btn.dataset.score);
      try {
        await addDoc(collection(db, "ratings"), {
          postId: p.id,
          score,
          createdAt: new Date()
        });
      } catch (e) {
        console.error(e);
        alert("評価の送信に失敗しました（権限/通信）。Console を確認してください。");
        return;
      }

      const newAvg = (p.avg * p.count + score) / (p.count + 1);
      p.avg = newAvg;
      p.count += 1;

      avgDiv.innerHTML = `平均難易度：<b>${newAvg.toFixed(2)}</b>（${p.count}人）`;

      localStorage.setItem(ratedKey, String(score));
      card.querySelectorAll("button").forEach(b => b.disabled = true);
      btn.classList.add("selected");
    };
  });

  timeline.appendChild(card);

  // 追加した要素だけ MathJax を当てる
  if (window.MathJax) {
    try {
      await MathJax.startup.promise;
      await MathJax.typesetPromise([texEl]);
    } catch (e) {
      console.warn("MathJax typeset failed:", e);
    }
  }
}

async function renderNextPage() {
  if (isLoading) return;     // ★追加
  isLoading = true;          // ★追加

  const next = currentList.slice(rendered, rendered + PAGE_SIZE);
  for (const p of next) await renderOne(p);
  rendered += next.length;

  if (rendered >= currentList.length) {
    sentinel.remove();
    if (observer) observer.disconnect();
  }

  isLoading = false;         // ★追加
}


function resetList(newList) {
  currentList = newList.slice();
  rendered = 0;

  // いったん全部消して、先頭から描画し直す
  timeline.innerHTML = "";
  timeline.appendChild(sentinel);

  if (observer) observer.disconnect();
  observer = new IntersectionObserver(async (entries) => {
    if (entries.some(e => e.isIntersecting)) {
      await renderNextPage();
    }
  }, { rootMargin: "600px" });

  observer.observe(sentinel);

  // 最初の1ページだけ即表示
  renderNextPage();
}

// 初期表示
resetList(sortPosts(enriched));

// 並び替えボタン（年度順 ↔ 難易度順）
sortToggle.onclick = () => {
  sortMode = (sortMode === "year") ? "difficulty" : "year";
  sortToggle.textContent = (sortMode === "year") ? "並び順：年度順" : "並び順：難易度順";
  resetList(sortPosts(currentList));
};



    // --- 検索 ---
function normalizeQuery(q) {
  return (q || "").trim().toLowerCase();
}

searchInput.addEventListener("input", async () => {
  const q = normalizeQuery(searchInput.value);

  if (!q) {
  resetList(sortPosts(enriched));
  return;
}


  const metaMatched = enriched.filter(p => {
    const meta = `${p.date}_${p.no} ${p.source}`.toLowerCase();
    return meta.includes(q);
  });

  const bodyMatched = enriched.filter(p =>
    (p.body || "").toLowerCase().includes(q)
  );

  const merged = [];
  const seen = new Set();
  for (const p of [...metaMatched, ...bodyMatched]) {
    if (seen.has(p.id)) continue;
    seen.add(p.id);
    merged.push(p);
  }

  resetList(sortPosts(merged));
});


  } // ← ★これを追加（main を閉じる）

  main(); // ← ★これにする（await main(); じゃない）
</script>
</body>
</html>
