<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>受験数学難問発掘会</title>
  <link rel="stylesheet" href="style.css">

  <!-- MathJax -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']]
      },
      options: {
        skipHtmlTags: ['script','noscript','style','textarea']
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .post {
      border-bottom: 1px solid #ddd;
      padding: 1.5em 0;
    }
    .meta {
      color: #666;
      font-size: 0.9em;
      margin-bottom: 0.5em;
    }
    .content .tex {
      white-space: pre-wrap;
      font-size: 1.05em;
      line-height: 1.7;
      background: #fafafa;
      padding: 1em;
      border-radius: 6px;
    }

  </style>
</head>

<body>
<header>
  <h1>受験数学難問発掘会</h1>
  <p>サイト作成: みかりな</p>
</header>

<main id="timeline"></main>
  

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, collection, addDoc, getDocs
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ---------- Firebase ---------- */

const firebaseConfig = {
  apiKey: "AIzaSyCfyTtuLXAmibDu2ebKSTUI-_ZKFrv8Syo",
  authDomain: "math-memo-870c0.firebaseapp.com",
  projectId: "math-memo-870c0",
  storageBucket: "math-memo-870c0.firebasestorage.app",
  messagingSenderId: "396039327636",
  appId: "1:396039327636:web:028aa61574d06623240981"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------- DOM ---------- */

const timeline = document.getElementById("timeline");

  /* ---------- util: encoding付き fetch ---------- */
async function fetchTextWithEncoding(url, encoding = "utf-8") {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${url}`);

  const buf = await res.arrayBuffer();
  return new TextDecoder(encoding).decode(buf);
}

/* ---------- util: LaTeX preamble 削除 ---------- */
function stripLatexPreamble(tex) {
  return tex
    // \documentclass ～ \begin{document} を削除
    .replace(/^[\s\S]*?\\begin\{document\}/, "")
    // \end{document} 以降を削除
    .replace(/\\end\{document\}[\s\S]*$/, "")
    .trim();
}



/* ---------- posts 自動生成 ---------- */

// GitHub API から posts/ フォルダ一覧を取得
const res = await fetch(
  "https://api.github.com/repos/mikarinachan/mikarinachan.github.io/contents/posts"
);
const files = await res.json();

// ファイル名規則をパースして posts を作る
const posts = files
  // 2025_6.tex 形式だけ採用（他の.texが混ざっても壊れない）
  .filter(f => /^(\d{4})_(\d+)\.tex$/.test(f.name))
  .map(f => {
    const m = f.name.match(/^(\d{4})_(\d+)\.tex$/);
    const year = m[1];

    return {
      id: f.name.replace(".tex", ""),
      tex: f.download_url, // raw URL（Pages配信に依存しない）
      source: "入試問題",
      date: year,
      round: "",
      encoding: year === "2025" ? "shift_jis" : "utf-8"
    };
  });



for (const p of posts) {
  if (!p.tex) {
    p.body = "";
    continue;
  }

  // posts.json に encoding があれば使う（なければ UTF-8）
  const encoding = p.encoding || "utf-8";

  try {
    p.body = stripLatexPreamble(
  await fetchTextWithEncoding(p.tex, encoding)
);

  } catch (e) {
    p.body = `（tex 読み込み失敗: ${p.tex}）`;
    console.error(e);
  }
}


/* ---------- ratings ---------- */

let ratingMap = {};
try {
  const ratingSnap = await getDocs(collection(db, "ratings"));
  ratingSnap.forEach(doc => {
    const { postId, score } = doc.data();
    (ratingMap[postId] ??= []).push(score);
  });
} catch (e) {
  console.warn("ratings 読み取り失敗（権限など）:", e);
  ratingMap = {};
}

/* ---------- 投稿データ ---------- */

const enriched = posts.map(p => {
  const scores = ratingMap[p.id] ?? [];
  const avg = scores.length
    ? scores.reduce((a,b)=>a+b,0) / scores.length
    : 0;

  return { ...p, avg, count: scores.length };
});

/* ---------- 難易度順 ---------- */

enriched.sort((a,b) => b.avg - a.avg);

/* ---------- 描画 ---------- */

for (const p of enriched) {
  const ratedKey = `rated_${p.id}`;
  const alreadyRated = localStorage.getItem(ratedKey);

  const div = document.createElement("div");
  div.className = "post";

  div.innerHTML = `
    <div class="meta">${p.date}｜${p.source}</div>

    <div class="content">
      <div class="tex"></div>
    </div>

    ${p.explain ? `<div class="explain">解説：${p.explain}</div>` : ""}

    ${p.answer ? `
      <div class="answer">
        <a href="${p.answer}" target="_blank">▶ 模範解答を見る</a>
      </div>` : ""}

    <div class="avg" data-avg>
      平均難易度：<b>${p.count ? p.avg.toFixed(2) : "未評価"}</b>
      ${p.count ? `（${p.count}人）` : ""}
    </div>

    <div class="rating">
      ${[1,2,3,4,5,6,7,8,9,10].map(n =>
        `<button data-score="${n}" ${alreadyRated ? "disabled" : ""}>${n}</button>`
      ).join("")}
    </div>
  `;

  const texEl = div.querySelector(".tex");
  texEl.textContent = p.body;


  const avgDiv = div.querySelector("[data-avg]");

  div.querySelectorAll("button").forEach(btn => {
    btn.onclick = async () => {
      if (localStorage.getItem(ratedKey)) return;

      const score = Number(btn.dataset.score);

      await addDoc(collection(db, "ratings"), {
        postId: p.id,
        score,
        createdAt: new Date()
      });

      const newAvg = (p.avg * p.count + score) / (p.count + 1);
      p.avg = newAvg;
      p.count += 1;

      avgDiv.innerHTML =
        `平均難易度：<b>${newAvg.toFixed(2)}</b>（${p.count}人）`;

      localStorage.setItem(ratedKey, score);
      div.querySelectorAll("button").forEach(b => b.disabled = true);
      btn.classList.add("selected");
    };
  });

  timeline.appendChild(div);
}

/* ---------- MathJax ---------- */

await MathJax.startup.promise;
await MathJax.typesetPromise();

</script>
</body>
</html>
