<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>受験数学難問発掘会</title>
  <link rel="stylesheet" href="style.css" />

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']]
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea']
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" defer></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      background: #f6f6f6;
      color: #111;
    }
    header {
      background: #222;
      color: #fff;
      padding: 1.2rem 1rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: .02em;
    }
    header p {
      margin: .25rem 0 0;
      opacity: .85;
      font-size: .95rem;
    }
    main {
      max-width: 980px;
      margin: 0 auto;
      padding: 1.2rem 1rem 3rem;
    }
    .post {
      background: #fff;
      border-radius: 14px;
      padding: 1.25rem 1.25rem 1rem;
      margin: 0 0 1rem;
      box-shadow: 0 1px 10px rgba(0,0,0,.06);
    }
    .meta {
      color: #666;
      font-size: 0.92rem;
      margin-bottom: 0.75rem;
    }
    .content .tex {
      white-space: pre-wrap;
      font-size: 1.03rem;
      line-height: 1.75;
      background: #fafafa;
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid #eee;
      overflow-wrap: anywhere;
    }
    .explain {
      margin-top: .8rem;
      padding: .75rem .9rem;
      border-left: 4px solid #ddd;
      background: #fcfcfc;
      border-radius: 10px;
    }
    .answer {
      margin-top: .7rem;
    }
    .answer a {
      color: #0b57d0;
      text-decoration: none;
    }
    .answer a:hover { text-decoration: underline; }

    .avg { margin-top: .9rem; color:#333; }
    .rating { margin-top: .6rem; display:flex; gap:.35rem; flex-wrap:wrap; }
    .rating button {
      border: 1px solid #bbb;
      background: #f4f4f4;
      border-radius: 8px;
      padding: .45rem .65rem;
      cursor: pointer;
      min-width: 2.4rem;
    }
    .rating button:hover { background: #eee; }
    .rating button:disabled { opacity: .55; cursor: not-allowed; }
    .rating button.selected { border-color: #111; background: #e7e7e7; }

    .system-note {
      padding: .8rem 1rem;
      border-radius: 12px;
      background: #fff3cd;
      border: 1px solid #ffe69c;
      color: #664d03;
      margin: 0 0 1rem;
    }
    .muted { color: #777; font-size: .95rem; }

    .qnum {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 2.2em;
  height: 2.2em;
  border: 2px solid #222;
  border-radius: 6px;
  font-weight: 700;
  background: #fff;
  margin-bottom: 0.6em;
}

  </style>
</head>

<body>
<header>
  <h1>受験数学難問発掘会</h1>
  <p>サイト作成: みかりな</p>
</header>

<main id="timeline"></main>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getFirestore, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  /* ---------- Firebase ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyCfyTtuLXAmibDu2ebKSTUI-_ZKFrv8Syo",
    authDomain: "math-memo-870c0.firebaseapp.com",
    projectId: "math-memo-870c0",
    storageBucket: "math-memo-870c0.firebasestorage.app",
    messagingSenderId: "396039327636",
    appId: "1:396039327636:web:028aa61574d06623240981"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  /* ---------- DOM ---------- */
  const timeline = document.getElementById("timeline");

  function showNote(html) {
    const div = document.createElement("div");
    div.className = "system-note";
    div.innerHTML = html;
    timeline.prepend(div);
  }

  /* ---------- util: encoding付き fetch ---------- */
  async function fetchTextWithEncoding(url, encoding = "utf-8") {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${url}`);
  const buf = await res.arrayBuffer();

  try {
    return new TextDecoder(encoding).decode(buf);
  } catch (e) {
    console.warn(`TextDecoder(${encoding}) 失敗 → utf-8で再試行`, e);
    return new TextDecoder("utf-8").decode(buf);
  }
}


  /* ---------- util: LaTeX → 表示用に正規化（MathJax非対応を剥がす） ---------- */
  function normalizeLatexForMathJax(tex) {
    return tex
      // document前後を削除
      .replace(/^[\s\S]*?\\begin\{document\}/, "")
      .replace(/\\end\{document\}[\s\S]*$/, "")

      // よくある前置き命令を削除（MathJaxは組版しない）
      .replace(/\\documentclass(\[[^\]]*\])?\{[^}]*\}/g, "")
      .replace(/\\usepackage(\[[^\]]*\])?\{[^}]*\}/g, "")
      .replace(/\\pagestyle\{[^}]+\}/g, "")
      .replace(/\\setlength\{[^}]+\}\{[^}]+\}/g, "")

      // 文字サイズ命令を削除（{\huge 6} → 6）
      .replace(/\\(?:tiny|scriptsize|footnotesize|small|normalsize|large|Large|LARGE|huge|Huge)\b/g, "")

      // 文章レイアウト環境は剥がす（中身だけ表示）
      .replace(/\\begin\{(?:flushleft|center|flushright)\}/g, "")
      .replace(/\\end\{(?:flushleft|center|flushright)\}/g, "")
      .replace(/\\begin\{(?:description|itemize|enumerate)\}/g, "")
      .replace(/\\end\{(?:description|itemize|enumerate)\}/g, "")
      // {4} みたいな行頭の番号をバッジ用HTMLに変換
      .replace(/^\s*\{(\d+)\}\s*$/m, '<span class="qnum">$1</span>')


      // item を見やすく
      // \item[(1)] → （1）
      .replace(/\\item\s*\[\((\d+)\)\]\s*/g, "\n（$1）")
      // \item[foo] → foo：
      .replace(/\\item\s*\[([^\]]+)\]\s*/g, "\n$1：")
      // \item → ・
      .replace(/\\item\b\s*/g, "\n・")

      // ありがちな整形
      .replace(/\u3000+/g, " ")        // 全角スペース多重を1個に
      .replace(/\r\n/g, "\n")          // 改行統一
      .replace(/\n{3,}/g, "\n\n")      // 空行詰め
      .trim();
  }

  /* ---------- posts 自動生成（GitHub API） ---------- */
  async function loadPostIndex() {
  const cacheKey = "posts_index_cache_v1";
  const cacheTimeKey = "posts_index_cache_time_v1";
  const now = Date.now();

  // 30分キャッシュ（好みで変更OK）
  const cached = localStorage.getItem(cacheKey);
  const cachedTime = Number(localStorage.getItem(cacheTimeKey) || "0");
  if (cached && (now - cachedTime) < 30 * 60 * 1000) {
    try { return JSON.parse(cached); } catch {}
  }

  const api = "https://api.github.com/repos/mikarinachan/mikarinachan.github.io/contents/posts";
  const r = await fetch(api, { cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status}: ${api}`);
  const files = await r.json();

  const posts = files
    .filter(f => typeof f?.name === "string"
  && /^(\d{4})_(\d+)\.tex$/.test(f.name)
  && typeof f?.download_url === "string" && f.download_url)

    .map(f => {
      const m = f.name.match(/^(\d{4})_(\d+)\.tex$/);
      const year = m[1];
      const no = m[2];
      return {
        id: f.name.replace(".tex", ""),
        tex: f.download_url,
        date: year,
        no: Number(no),
        source: "入試問題",
        encoding: year === "2025" ? "shift_jis" : "utf-8"
      };
    });

  posts.sort((a, b) => (b.date.localeCompare(a.date) || a.no - b.no));

  // キャッシュ保存
  localStorage.setItem(cacheKey, JSON.stringify(posts));
  localStorage.setItem(cacheTimeKey, String(now));

  return posts;
}


  /* ---------- ratings（落ちても表示継続） ---------- */
  async function loadRatings() {
    let ratingMap = {};
    try {
      const snap = await getDocs(collection(db, "ratings"));
      snap.forEach(doc => {
        const { postId, score } = doc.data() || {};
        if (!postId || typeof score !== "number") return;
        (ratingMap[postId] ??= []).push(score);
      });
    } catch (e) {
      console.warn("ratings 読み取り失敗（権限など）:", e);
      ratingMap = {};
      showNote("⚠️ 難易度データ（Firestore）が読み取れませんでした。表示は続行します。<div class='muted'>Console に詳細があります。</div>");
    }
    return ratingMap;
  }

  /* ---------- tex 本文読み込み ---------- */
  async function loadBodies(posts) {
    for (const p of posts) {
      try {
        const raw = await fetchTextWithEncoding(p.tex, p.encoding || "utf-8");
        p.body = normalizeLatexForMathJax(raw);
      } catch (e) {
        console.error(e);
        p.body = `（tex 読み込み失敗: ${p.tex}）`;
      }
    }
    return posts;
  }

  /* ---------- 描画 ---------- */
  function buildCard(p, alreadyRated) {
    const div = document.createElement("div");
    div.className = "post";

    div.innerHTML = `
      <div class="meta">${p.date}｜${p.source}</div>

      <div class="content">
        <div class="tex"></div>
      </div>

      ${p.explain ? `<div class="explain">解説：${p.explain}</div>` : ""}

      ${p.answer ? `
        <div class="answer">
          <a href="${p.answer}" target="_blank" rel="noopener">▶ 模範解答を見る</a>
        </div>` : ""}

      <div class="avg" data-avg>
        平均難易度：<b>${p.count ? p.avg.toFixed(2) : "未評価"}</b>
        ${p.count ? `（${p.count}人）` : ""}
      </div>

      <div class="rating">
        ${[1,2,3,4,5,6,7,8,9,10].map(n =>
          `<button data-score="${n}" ${alreadyRated ? "disabled" : ""}>${n}</button>`
        ).join("")}
      </div>
    `;
    return div;
  }

  async function main() {
    let posts = [];
    try {
      posts = await loadPostIndex();
    } catch (e) {
      console.error(e);
      showNote(`❌ posts/ の一覧取得に失敗しました。<div class="muted">${String(e.message || e)}</div>`);
      return;
    }

    if (posts.length === 0) {
      showNote("⚠️ posts/ に対象ファイルが見つかりません。<div class='muted'>ファイル名は <b>2025_6.tex</b> のように <b>YYYY_N.tex</b> 形式にしてください。</div>");
      return;
    }

    // ratings
    const ratingMap = await loadRatings();

    // tex本文
    await loadBodies(posts);

    // enriched
    const enriched = posts.map(p => {
      const scores = ratingMap[p.id] ?? [];
      const avg = scores.length ? (scores.reduce((a,b)=>a+b,0) / scores.length) : 0;
      return { ...p, avg, count: scores.length };
    });

    // 表示順：いまは「年度降順→番号昇順」。難易度順にしたければ下の行を有効化
    // enriched.sort((a,b) => b.avg - a.avg);

    for (const p of enriched) {
      const ratedKey = `rated_${p.id}`;
      const alreadyRated = localStorage.getItem(ratedKey);

      const card = buildCard(p, alreadyRated);
      const texEl = card.querySelector(".tex");
      texEl.innerHTML = p.body;

      const avgDiv = card.querySelector("[data-avg]");

      // 評価ボタン
      card.querySelectorAll("button").forEach(btn => {
        btn.onclick = async () => {
          if (localStorage.getItem(ratedKey)) return;

          const score = Number(btn.dataset.score);
          try {
            await addDoc(collection(db, "ratings"), {
              postId: p.id,
              score,
              createdAt: new Date()
            });
          } catch (e) {
            console.error(e);
            alert("評価の送信に失敗しました（権限/通信）。Console を確認してください。");
            return;
          }

          const newAvg = (p.avg * p.count + score) / (p.count + 1);
          p.avg = newAvg;
          p.count += 1;

          avgDiv.innerHTML = `平均難易度：<b>${newAvg.toFixed(2)}</b>（${p.count}人）`;

          localStorage.setItem(ratedKey, String(score));
          card.querySelectorAll("button").forEach(b => b.disabled = true);
          btn.classList.add("selected");
        };
      });

      timeline.appendChild(card);

      // 追加した要素だけ MathJax を当てる（確実）
      if (window.MathJax) {
        try {
          await MathJax.startup.promise;
          await MathJax.typesetPromise([texEl]);
        } catch (e) {
          console.warn("MathJax typeset failed:", e);
        }
      }
    }
  }

  await main();
</script>
</body>
</html>
